# Lab4 数据操纵实现说明

## 一、任务1：顺序扫描算子（SeqScanExecutor）

### 1. rid_ 的作用
`rid_` 用于记录当前满足选择条件的元组的位置（Record ID），包含页号和槽号。

### 2. 实现的函数

#### (1) beginTuple()
**功能**：定位到表中第一条满足选择条件的元组。

**实现思路**：
1. 创建表的记录扫描迭代器 `scan_`
2. 使用 `scan_` 迭代扫描表中的元组
3. 对每条元组调用 `eval_conds()` 检查是否满足所有选择条件
4. 找到第一条满足条件的元组后，将其 Rid 记录在 `rid_` 中并停止

#### (2) nextTuple()
**功能**：定位到表中下一条满足选择条件的元组。

**实现思路**：
1. 调用 `scan_->next()` 移动到下一条记录
2. 继续扫描，对每条元组检查是否满足选择条件
3. 找到满足条件的元组后停止，将其 Rid 记录在 `rid_` 中

#### (3) is_end()
**功能**：判断是否没有结果了。

**实现思路**：调用 `scan_->is_end()` 判断迭代器是否到达末尾。

#### (4) Next()
**功能**：返回下一条结果元组。

**实现思路**：调用 `fh_->get_record(rid_, context_)` 获取 `rid_` 标识的记录并返回。

#### (5) eval_cond()
**功能**：判断一个元组是否满足一个基本选择条件。

**实现思路**：
1. 获取条件左部列的元数据和在记录中的偏移位置
2. 获取条件右部的值（可能是常量或另一列的值）
3. 使用 `ix_compare()` 函数比较左右两部分的值
4. 根据条件中的比较运算符（`OP_EQ`、`OP_NE`、`OP_LT`、`OP_GT`、`OP_LE`、`OP_GE`）返回比较结果

---

## 二、任务2：投影算子（ProjectionExecutor）

### 1. prev_ 的作用
`prev_` 是指向子节点算子的指针，用于获取需要进行投影操作的输入元组。

### 2. 实现的函数

#### (1) beginTuple()
**功能**：定位到第一条结果元组。

**实现思路**：调用 `prev_->beginTuple()` 使子节点算子定位到其第一条结果元组。

#### (2) nextTuple()
**功能**：定位到下一条结果元组。

**实现思路**：调用 `prev_->nextTuple()` 使子节点算子定位到其下一条结果元组。

#### (3) is_end()
**功能**：判断是否没有结果了。

**实现思路**：调用 `prev_->is_end()` 判断子节点算子是否已无输入元组。

#### (4) Next()
**功能**：返回下一条结果元组（投影后的元组）。

**实现思路**：
1. 调用 `prev_->Next()` 获取子节点算子的当前元组
2. 创建大小为 `len_`（投影后字段总长度）的结果元组
3. 根据 `sel_idxs_`（选择的列索引）和 `cols_`（投影后的列元数据），将子节点元组的指定字段复制到结果元组中
4. 返回投影后的元组

---

## 三、任务3：嵌套循环连接算子（NestedLoopJoinExecutor）

### 1. left_ 和 right_ 的作用
- `left_`：指向左子节点算子的指针，提供连接操作的左表数据
- `right_`：指向右子节点算子的指针，提供连接操作的右表数据

### 2. 实现的函数

#### (1) beginTuple()
**功能**：定位到第一条结果元组（满足连接条件的元组对）。

**实现思路**：
1. 调用 `left_->beginTuple()` 定位到左子节点的第一条元组
2. 如果左子节点不为空，调用 `right_->beginTuple()` 定位到右子节点的第一条元组
3. 使用嵌套循环检查每对左右元组是否满足连接条件
4. 找到第一对满足条件的元组后停止

#### (2) nextTuple()
**功能**：定位到下一条结果元组（下一对满足连接条件的元组）。

**实现思路**：
1. 首先尝试移动到右子节点的下一条记录
2. 如果右子节点还有记录，检查当前元组对是否满足连接条件
3. 如果右子节点已扫描完毕，移动到左子节点的下一条记录，并重新开始扫描右子节点
4. 重复此过程直到找到满足条件的元组对或所有元组对都已检查完毕

#### (3) is_end()
**功能**：判断是否没有结果了。

**实现思路**：返回 `isend` 标志，该标志在扫描完所有元组对后设置为 true。

#### (4) Next()
**功能**：返回下一条结果元组（连接后的元组）。

**实现思路**：
1. 分别获取左右子节点的当前元组
2. 创建大小为 `len_`（左右元组长度之和）的结果元组
3. 先复制左子节点元组的数据到结果元组
4. 再将右子节点元组的数据追加到结果元组后面
5. 返回连接后的元组

#### (5) eval_cond()
**功能**：判断两个元组是否满足一个基本连接条件。

**实现思路**：
1. 获取连接条件左部列的元数据
2. 根据列的偏移量判断该列来自左子节点还是右子节点，获取对应的数据地址
3. 同样处理右部表达式（可能是列或常量值）
4. 使用 `ix_compare()` 比较左右两部分的值
5. 根据比较运算符返回判断结果

**关键点**：需要根据列的 `offset` 判断它来自左表还是右表：
- 如果 `offset < left_->tupleLen()`，则来自左表
- 否则来自右表，需要调整偏移量为 `offset - left_->tupleLen()`

---

## 四、任务4：修改算子（UpdateExecutor）

### 1. rids_ 的来源
`rids_` 是通过执行计划生成时，先通过选择操作找到所有满足更新条件的元组的 Rid 列表。

### 2. 实现的函数

#### Next()
**功能**：执行更新操作。

**实现思路**：
1. 遍历 `rids_` 中的所有记录位置
2. 对每个 Rid，调用 `fh_->get_record()` 获取原记录
3. 遍历 `set_clauses_`（SET 子句列表），对每个需要更新的字段：
   - 获取列的元数据
   - 检查类型是否兼容
   - 初始化新值的原始数据
   - 使用 `memcpy()` 更新记录中对应字段的值
4. 调用 `fh_->update_record()` 将更新后的记录写回磁盘
5. 返回 nullptr（更新操作不返回记录）

---

## 五、任务5：删除算子（DeleteExecutor）

### 1. rids_ 的来源
`rids_` 是通过执行计划生成时，先通过选择操作找到所有满足删除条件的元组的 Rid 列表。

### 2. 实现的函数

#### Next()
**功能**：执行删除操作。

**实现思路**：
1. 遍历 `rids_` 中的所有记录位置
2. 对每个 Rid，调用 `fh_->delete_record()` 删除该记录
3. 返回 nullptr（删除操作不返回记录）

---

## 六、关键技术点总结

### 1. 火山模型
所有算子都实现了以下接口：
- `beginTuple()`：定位到第一条结果
- `nextTuple()`：移动到下一条结果
- `Next()`：返回当前结果
- `is_end()`：判断是否结束

这种统一的接口使得算子可以像流水线一样组合使用。

### 2. 迭代器模式
- `RecScan` 和 `RmScan` 提供了遍历表记录的抽象接口
- 各个算子通过迭代器模式逐条处理记录，而不是一次性加载所有数据

### 3. 条件评估
- 使用 `eval_cond()` 评估单个条件
- 使用 `eval_conds()` 评估多个条件（通过 `std::all_of` 实现 AND 语义）
- 使用 `ix_compare()` 进行类型感知的值比较

### 4. 内存管理
- 使用 `std::unique_ptr<RmRecord>` 自动管理记录内存
- 使用 `memcpy()` 高效地复制记录数据

### 5. 嵌套循环连接优化考虑
当前实现是标准的嵌套循环连接算法（时间复杂度 O(n×m)）。
实际系统中可能的优化：
- 使用索引加速右表查找（索引嵌套循环连接）
- 使用哈希连接或排序归并连接
- 选择较小的表作为外层循环

---

## 七、测试方法

### 单元测试命令
```bash
# 任务1和2：投影和顺序扫描
cd src/test/query
python3 query_unit_test.py basic_query_test2.sql

# 任务3：连接
cd src/test/query
python3 query_unit_test.py basic_query_test5.sql

# 任务4：更新
cd src/test/query
python3 query_unit_test.py basic_query_test3.sql

# 任务5：删除
cd src/test/query
python3 query_unit_test.py basic_query_test4.sql

# 全部测试
cd src/test/query
python3 query_test_basic.py
```

---

## 八、常见问题与注意事项

1. **空指针检查**：在调用子算子的方法前，确保指针已正确初始化
2. **类型匹配**：UPDATE 操作时要检查类型兼容性
3. **内存对齐**：使用 `memcpy()` 时要确保偏移量和长度正确
4. **迭代器状态**：调用 `next()` 前要检查 `is_end()`，避免越界
5. **连接条件处理**：正确判断列来自左表还是右表，正确计算偏移量

---

## 九、实现亮点

1. **完整的注释**：每个函数都有详细的中文注释说明其功能和实现逻辑
2. **健壮的错误处理**：对类型不匹配等异常情况进行检查
3. **高效的实现**：使用 `memcpy()` 等高效操作，避免不必要的数据复制
4. **符合火山模型**：所有算子都遵循统一的接口规范，易于组合和扩展
5. **条件评估优化**：使用短路求值（`std::all_of`）提高效率
