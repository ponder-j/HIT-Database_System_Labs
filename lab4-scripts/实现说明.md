# Lab4 数据操纵实现说明

## 一、任务1：顺序扫描算子（SeqScanExecutor）

### 1. rid_ 的作用
`rid_` 用于记录当前满足选择条件的元组的位置（Record ID），包含页号和槽号。

### 2. 实现的函数

#### (1) beginTuple()

**1. 方法声明：**
```cpp
void beginTuple() override;
```

**2. 方法实现思路：**
1. 创建表的记录扫描迭代器 `scan_`。
2. 使用 `scan_` 迭代扫描表中的元组。
3. 对每条元组调用 `eval_conds()` 检查是否满足所有选择条件。
4. 找到第一条满足条件的元组后，将其 Rid 记录在 `rid_` 中并停止扫描。

**3. 方法实现难点：**
需要正确初始化记录迭代器，并确保循环在找到第一个匹配项后能正确终止。

#### (2) nextTuple()

**1. 方法声明：**
```cpp
void nextTuple() override;
```

**2. 方法实现思路：**
1. 从当前 `scan_` 指向的记录的下一条开始，继续迭代扫描。
2. 对扫描到的每条元组，检查其是否满足所有选择条件。
3. 找到下一条满足条件的元组后，更新 `rid_` 并停止。

**3. 方法实现难点：**
关键在于要从上一条找到的记录之后开始扫描，而不是从头开始，这通过调用 `scan_->next()` 来实现。

#### (3) is_end()

**1. 方法声明：**
```cpp
bool is_end() const override;
```

**2. 方法实现思路：**
直接调用记录扫描迭代器 `scan_` 的 `is_end()` 方法，判断是否已经扫描到表末尾。

**3. 方法实现难点：**
该方法实现较为简单，无明显难点。

#### (4) Next()

**1. 方法声明：**
```cpp
std::unique_ptr<RmRecord> Next() override;
```

**2. 方法实现思路：**
根据当前 `rid_` 中存储的记录位置，调用 `RmFileHandle::get_record()` 方法获取完整的元组数据，并以 `std::unique_ptr<RmRecord>` 的形式返回。

**3. 方法实现难点：**
需要确保 `rid_` 是有效的，并且 `Context` 对象被正确传递给 `get_record`。

#### (5) eval_cond()

**1. 方法声明：**
```cpp
bool eval_cond(const RmRecord *rec, const Condition &cond, const std::vector<ColMeta> &rec_cols);
```

**2. 参数列表：**
| 参数 | 类型 | 含义 |
|---|---|---|
| rec | const RmRecord* | 指向待检查元组的指针 |
| cond | const Condition& | 单个选择条件 |
| rec_cols | const std::vector<ColMeta>& | 元组的列元数据 |

**3. 方法实现思路：**
1. 获取条件左部表达式（列）的元数据和数据指针。
2. 判断条件右部是常量值还是列，并获取其类型和数据指针。
3. 调用 `ix_compare()` 函数对左右两边的值进行比较。
4. 根据条件中的比较运算符（如 `OP_EQ`, `OP_LT` 等）返回最终的布尔比较结果。

**3. 方法实现难点：**
难点在于正确处理不同数据类型（`ColType`）的比较，`ix_compare` 辅助函数的正确使用是关键。同时需要正确解析 `Condition` 结构，区分右部是值还是列。

---

## 二、任务2：投影算子（ProjectionExecutor）

### 1. prev_ 的作用
`prev_` 是指向子节点算子（如 `SeqScanExecutor`）的智能指针，投影算子通过它来获取待处理的输入元组。

### 2. 实现的函数

#### (1) beginTuple()

**1. 方法声明：**
```cpp
void beginTuple() override;
```

**2. 方法实现思路：**
直接调用子节点算子 `prev_` 的 `beginTuple()` 方法，将定位操作传递给下游算子，使其准备好提供第一条元组。

**3. 方法实现难点：**
该方法为简单的调用传递，无明显难点。

#### (2) nextTuple()

**1. 方法声明：**
```cpp
void nextTuple() override;
```

**2. 方法实现思路：**
直接调用子节点算子 `prev_` 的 `nextTuple()` 方法，使其定位到下一条元组。

**3. 方法实现难点：**
该方法为简单的调用传递，无明显难点。

#### (3) is_end()

**1. 方法声明：**
```cpp
bool is_end() const override;
```

**2. 方法实现思路：**
调用子节点算子 `prev_` 的 `is_end()` 方法，并返回其结果，以判断是否还有输入元组。

**3. 方法实现难点：**
该方法为简单的调用传递，无明显难点。

#### (4) Next()

**1. 方法声明：**
```cpp
std::unique_ptr<RmRecord> Next() override;
```

**2. 方法实现思路：**
1. 调用 `prev_->Next()` 从子节点获取原始元组。
2. 创建一个新的 `RmRecord` 对象，其大小为投影后所有列的总长度。
3. 遍历需要投影的列（由 `sel_idxs_` 和 `cols_` 定义），使用 `memcpy` 从原始元组中将指定列的数据复制到新的 `RmRecord` 对象中。
4. 返回这个只包含投影列的新元组。

**3. 方法实现难点：**
难点在于精确计算每个投影列在原始元组和新元组中的偏移量（`offset`）和长度（`len`），并使用 `memcpy` 正确地复制数据。

---

## 三、任务3：嵌套循环连接算子（NestedLoopJoinExecutor）

### 1. left_ 和 right_ 的作用
- `left_`：指向左子节点算子的指针，作为嵌套循环的外层循环，提供左表数据。
- `right_`：指向右子节点算子的指针，作为嵌套循环的内层循环，提供右表数据。

### 2. 实现的函数

#### (1) beginTuple()

**1. 方法声明：**
```cpp
void beginTuple() override;
```

**2. 方法实现思路：**
1. 调用 `left_->beginTuple()` 定位到左表的第一条元组。
2. 如果左表不为空，则调用 `right_->beginTuple()` 定位到右表的第一条元组。
3. 进入一个嵌套循环，持续从右表和左表获取下一条记录，直到找到第一对满足所有连接条件 `eval_conds()` 的元组，然后停止。

**3. 方法实现难点：**
需要正确处理两个子节点的初始化，并实现嵌套循环逻辑来找到第一个匹配的元组对。

#### (2) nextTuple()

**1. 方法声明：**
```cpp
void nextTuple() override;
```

**2. 方法实现思路：**
1. 首先尝试在内层循环（右表）中移动，即调用 `right_->nextTuple()`。
2. 循环检查右表的剩余元组，看是否与当前左表元组匹配。
3. 如果右表扫描完毕，则在外层循环（左表）中移动，即调用 `left_->nextTuple()`，然后重置右表扫描 `right_->beginTuple()`。
4. 重复此过程，直到找到下一对满足连接条件的元组，或者扫描完所有元组对。

**3. 方法实现难点：**
难点在于正确管理嵌套循环的状态。当内层循环结束时，需要正确地推进外层循环并重置内层循环。

#### (3) is_end()

**1. 方法声明：**
```cpp
bool is_end() const override;
```

**2. 方法实现思路：**
通过一个布尔成员变量 `isend` 来判断。当外层循环（左表）也扫描结束后，即 `left_->is_end()` 为真时，将 `isend` 设为 `true`。

**3. 方法实现难点：**
需要确保在 `nextTuple()` 的逻辑中，当所有可能的元组对都检查完毕后，能正确地更新 `isend` 标志。

#### (4) Next()

**1. 方法声明：**
```cpp
std::unique_ptr<RmRecord> Next() override;
```

**2. 方法实现思路：**
1. 分别调用 `left_->Next()` 和 `right_->Next()` 获取当前匹配的左右元组。
2. 创建一个大小为左右元组长度之和的新 `RmRecord` 对象。
3. 使用 `memcpy` 先将左元组的数据完整复制到新元组的起始位置。
4. 接着将右元组的数据复制到新元组中紧随左元组数据之后的位置。
5. 返回这个拼接而成的新元组。

**3. 方法实现难点：**
关键在于正确计算拼接后元组的总长度，以及右元组数据在新元组中的起始偏移量（即左元组的长度）。

#### (5) eval_cond()

**1. 方法声明：**
```cpp
bool eval_cond(const RmRecord *lhs_rec, const RmRecord *rhs_rec, const Condition &cond, const std::vector<ColMeta> &rec_cols);
```

**2. 参数列表：**
| 参数 | 类型 | 含义 |
|---|---|---|
| lhs_rec | const RmRecord* | 指向左表的当前元组 |
| rhs_rec | const RmRecord* | 指向右表的当前元组 |
| cond | const Condition& | 单个连接条件 |
| rec_cols | const std::vector<ColMeta>& | 连接后元组的列元数据 |

**3. 方法实现思路：**
1. 对于条件中的每个表达式（列），根据其在 `rec_cols` 中的 `offset` 判断它属于左表还是右表。
2. 如果 `offset < left_->tupleLen()`，则从 `lhs_rec` 中获取数据；否则，从 `rhs_rec` 中获取数据，并调整偏移量（减去 `left_->tupleLen()`）。
3. 获取左右两边的数据指针后，调用 `ix_compare()` 进行比较。
4. 根据比较运算符返回结果。

**3. 方法实现难点：**
最主要的难点是根据列的偏移量正确判断其来源（左表或右表），并相应地调整数据指针的计算方式。这是实现连接条件判断的核心。

---

## 四、任务4：修改算子（UpdateExecutor）

### 1. rids_ 的来源
`rids_` 是一个 `Rid` 向量，它在执行计划生成阶段，由上游的扫描或索引节点提供。这些 `Rid` 指向了所有满足 `WHERE` 子句条件的、需要被更新的元组。

### 2. 实现的函数

#### (1) Next()

**1. 方法声明：**
```cpp
std::unique_ptr<RmRecord> Next() override;
```

**2. 方法实现思路：**
1. 遍历 `rids_` 列表中的每一个 `Rid`。
2. 对于每个 `Rid`，首先调用 `fh_->get_record()` 获取原始记录。
3. 遍历 `set_clauses_`（即 `SET` 子句列表），对于每一个要修改的字段：
    a. 获取目标列的元数据，并检查待更新值的类型是否兼容。
    b. 使用 `memcpy` 将新值的数据覆盖到从 `get_record()` 获取的记录缓存区的相应位置。
4. 调用 `fh_->update_record()`，将修改后的记录数据写回磁盘。
5. 由于 `UPDATE` 操作不向上层返回元组，因此最后返回 `nullptr`。

**3. 方法实现难点：**
难点在于需要先读出（`get_record`）再修改，然后写回（`update_record`）。在修改内存中的记录时，必须使用 `memcpy` 确保数据按字节正确复制，特别是对于不同长度的字符串和数值类型。

---

## 五、任务5：删除算子（DeleteExecutor）

### 1. rids_ 的来源
与 `UpdateExecutor` 类似，`rids_` 是由上游节点（如扫描操作）提供的、所有满足 `WHERE` 子句条件的、需要被删除的元组的 `Rid` 列表。

### 2. 实现的函数

#### (1) Next()

**1. 方法声明：**
```cpp
std::unique_ptr<RmRecord> Next() override;
```

**2. 方法实现思路：**
1. 遍历 `rids_` 列表中的每一个 `Rid`。
2. 对每个 `Rid`，直接调用 `fh_->delete_record()` 来删除磁盘上对应的记录。
3. `DELETE` 操作也不向上层返回元组，因此最后返回 `nullptr`。

**3. 方法实现难点：**
此方法的实现相对直接，主要依赖于底层 `RmFileHandle::delete_record` 的正确实现。本身逻辑较为简单，无明显难点。
