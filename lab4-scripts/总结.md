# 实验4：数据操纵实现总结

  

## 一、实验概述与目标

本实验围绕 Rucbase 火山模型下的数据操纵执行器实现展开，完成并梳理了以下算子：

- 顺序扫描（SeqScanExecutor）

- 投影（ProjectionExecutor）

- 嵌套循环连接（NestedLoopJoinExecutor）

- 修改（UpdateExecutor）

- 删除（DeleteExecutor）

  

目标是掌握统一执行接口（beginTuple/nextTuple/Next/is_end），理解算子间通过迭代器组合形成执行管线的方式，并在保证正确性的前提下实现高效的条件评估与元组构造/修改。

  

## 二、核心实现要点

### 1. 顺序扫描（SeqScanExecutor）

- 关键成员：`rid_` 表示当前满足条件的记录位置（页号+槽号），`scan_` 为表记录迭代器。

- beginTuple/nextTuple：驱动 `scan_` 迭代，寻找并记录第一条/下一条满足选择条件的 `rid_`。

- is_end：由 `scan_` 的结束状态判定。

- Next：根据 `rid_` 调用 `RmFileHandle::get_record` 取回当前记录。

- 条件评估：`eval_cond/ eval_conds` 提取左右表达式值，调用 `ix_compare` 做类型感知比较，并按操作符返回布尔结果。

  

### 2. 投影（ProjectionExecutor）

- 关键成员：`prev_` 为子算子执行器；`cols_/sel_idxs_/len_` 描述投影列及结果长度。

- beginTuple/nextTuple/is_end：全部委托给 `prev_`。

- Next：从 `prev_->Next()` 取得输入元组，按 `sel_idxs_` 和列元数据拷贝所需字段，构造投影后记录。

  

### 3. 嵌套循环连接（NestedLoopJoinExecutor）

- 关键成员：`left_`、`right_` 为左右子算子；连接条件通过 `eval_cond/ eval_conds` 判断。

- beginTuple：left 定位首元组后，right 定位首元组，进入嵌套循环，找到第一对满足条件的元组对。

- nextTuple：优先推进 `right_`，耗尽后推进 `left_` 并重置 `right_` 至首元组，持续寻找下一对满足条件的组合。

- is_end：依据左侧是否耗尽（以及右侧重扫后无匹配）判定。

- Next：拼接左右元组的二进制数据生成连接结果；偏移按左右长度顺序相加。

- 条件评估要点：根据列 `offset` 判断来源于左表还是右表；若大于左表总长则从右表读取并调整偏移。

  

### 4. 修改（UpdateExecutor）

- 数据来源：`rids_` 由上游选择计划预先收集。

- Next：遍历 `rids_`，取出记录，按 `set_clauses_` 和列元数据进行类型检查与值覆盖（`memcpy`），调用 `update_record` 写回。

  

### 5. 删除（DeleteExecutor）

- 数据来源：同样由上游选择计划生成的 `rids_`。

- Next：遍历 `rids_`，依次调用 `delete_record` 删除对应记录。

  

## 三、关键技术与经验

- 火山模型：统一的四接口让算子能以“拉取”方式串联，天然支持管线化执行与算子复用。

- 迭代器模式：`RmScan/RecScan` 将表遍历与存储细节封装，算子只需关注条件与字段搬运。

- 条件评估：抽象出单条件 `eval_cond` 与多条件 `eval_conds`（AND 语义、短路），比较使用 `ix_compare`，减少类型分支重复代码。

- 记录与内存：基于列 `offset/len` 做定长拷贝，投影/连接用 `memcpy` 批量搬运，避免临时对象开销；使用 `unique_ptr<RmRecord>` 管理内存。

- 连接偏移处理：连接后元组是左右拼接；判断列归属时以 `left_->tupleLen()` 为阈值，右表偏移需减去左长。

  

## 四、测试与验证

- 单项测试：

- 顺序扫描/投影：`basic_query_test2.sql`

- 连接：`basic_query_test5.sql`

- 修改：`basic_query_test3.sql`

- 删除：`basic_query_test4.sql`

- 组合测试：`query_test_basic.py`

- 注意：select 输出需严格按框架约定写入 `output.txt`，错误 SQL 打印 `failure`。

  

## 五、问题与解决

- 迭代器边界：在 `next()` 前后都需检查 `is_end()`，避免越界访问。

- 空指针与初始化：`prev_/left_/right_/scan_` 的创建与生命周期需明确；在首次 begin 前不调用 Next。

- 类型匹配：UPDATE 时做类型与长度校验，避免跨类型写入；常量与列比较保持一致的类型视图。

- 偏移计算：连接和投影场景下的偏移易错，统一用列元数据驱动，避免手算魔数。

  

## 六、性能与优化思考

- NLJ 优化：

- 索引嵌套循环连接（右表走索引定位）

- 过滤下推（尽量早筛右表）

- 选择较小表为外层，减少重扫次数

- 投影优化：

- 尽早投影（下推）降低上层算子数据宽度

- 对定长列采用批量拷贝，减少字段粒度循环

- 扫描优化：

- 条件短路评估减少比较次数

- 合理的页内顺序访问提升缓存命中

  

## 七、收获与反思

- 统一的 Volcano 接口设计让算子组合保持高度一致性，利于调试与扩展。

- 条件评估与列元数据的抽象显著降低了代码重复，提高了可维护性。

- 在连接场景中，正确处理列来源与偏移是保证正确性的关键细节。

- 后续可在此基础上尝试更多执行策略（哈希连接、排序归并连接）、谓词/投影下推、以及基于代价的计划选择；同时与事务、恢复、并发控制模块结合，完善执行的隔离性与持久性。

  

—— 完 ——