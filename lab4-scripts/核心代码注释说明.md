# Lab4 核心代码注释说明

## 快速导航

### 1. 顺序扫描算子 (SeqScanExecutor)

```cpp
// 功能：扫描表中的所有记录，返回满足条件的记录

void beginTuple() {
    // 步骤1：创建表的扫描迭代器
    scan_ = std::make_unique<RmScan>(fh_);
    
    // 步骤2：找到第一条满足条件的记录
    while (!scan_->is_end()) {
        rid_ = scan_->rid();                           // 获取当前记录位置
        auto rec = fh_->get_record(rid_, context_);    // 读取记录
        if (eval_conds(rec.get(), fed_conds_, cols_)) { // 检查是否满足条件
            break;                                      // 找到了，停止
        }
        scan_->next();                                 // 没找到，继续下一条
    }
}

void nextTuple() {
    scan_->next();                                     // 移动到下一条记录
    // 然后重复 beginTuple 中的查找逻辑
}

std::unique_ptr<RmRecord> Next() {
    return fh_->get_record(rid_, context_);            // 返回 rid_ 指向的记录
}

bool is_end() const {
    return scan_->is_end();                            // 检查是否扫描完毕
}

bool eval_cond(...) {
    // 步骤1：获取左部的值
    auto lhs_col = get_col(rec_cols, cond.lhs_col);
    char *lhs_data = rec->data + lhs_col->offset;
    
    // 步骤2：获取右部的值（可能是常量或列）
    char *rhs_data = cond.is_rhs_val ? 
                     cond.rhs_val.raw->data :          // 常量值
                     rec->data + rhs_col->offset;      // 列值
    
    // 步骤3：比较
    int cmp = ix_compare(lhs_data, rhs_data, lhs_col->type, lhs_col->len);
    
    // 步骤4：根据运算符返回结果
    switch (cond.op) {
        case OP_EQ: return cmp == 0;                   // =
        case OP_NE: return cmp != 0;                   // !=
        case OP_LT: return cmp < 0;                    // <
        case OP_GT: return cmp > 0;                    // >
        case OP_LE: return cmp <= 0;                   // <=
        case OP_GE: return cmp >= 0;                   // >=
    }
}
```

**关键概念：**
- `rid_`：记录位置（页号 + 槽号）
- `scan_`：表扫描迭代器
- `fh_`：文件句柄，用于读取记录
- `eval_conds`：检查记录是否满足所有条件（AND 逻辑）

---

### 2. 投影算子 (ProjectionExecutor)

```cpp
// 功能：从输入记录中选择指定的列

void beginTuple() {
    prev_->beginTuple();                               // 让子算子开始
}

void nextTuple() {
    prev_->nextTuple();                                // 让子算子移动
}

std::unique_ptr<RmRecord> Next() {
    auto prev_rec = prev_->Next();                     // 获取子算子的记录
    auto proj_rec = std::make_unique<RmRecord>(len_); // 创建投影后的记录
    
    // 复制选定的列
    for (size_t i = 0; i < sel_idxs_.size(); i++) {
        size_t prev_idx = sel_idxs_[i];               // 原记录中的列索引
        auto &prev_col = prev_->cols()[prev_idx];     // 原列的元数据
        auto &proj_col = cols_[i];                    // 新列的元数据
        
        memcpy(proj_rec->data + proj_col.offset,     // 目标位置
               prev_rec->data + prev_col.offset,      // 源位置
               proj_col.len);                         // 复制长度
    }
    
    return proj_rec;
}

bool is_end() const {
    return prev_->is_end();                            // 检查子算子是否结束
}
```

**关键概念：**
- `prev_`：子算子（数据来源）
- `sel_idxs_`：要选择的列的索引列表
- `cols_`：投影后的列元数据
- `len_`：投影后记录的总长度

---

### 3. 嵌套循环连接算子 (NestedLoopJoinExecutor)

```cpp
// 功能：执行笛卡尔积，返回满足连接条件的记录对

void beginTuple() {
    left_->beginTuple();                               // 外层：左表
    if (!left_->is_end()) {
        right_->beginTuple();                          // 内层：右表
        
        // 找到第一对满足连接条件的记录
        while (!left_->is_end()) {
            while (!right_->is_end()) {
                auto left_rec = left_->Next();
                auto right_rec = right_->Next();
                if (eval_conds(left_rec.get(), right_rec.get(), ...)) {
                    return;                            // 找到了
                }
                right_->nextTuple();
            }
            left_->nextTuple();                        // 右表扫完，移动左表
            if (!left_->is_end()) {
                right_->beginTuple();                  // 重新扫描右表
            }
        }
    }
}

void nextTuple() {
    right_->nextTuple();                               // 先尝试移动右表
    
    // 在右表中继续找
    while (!right_->is_end()) {
        if (eval_conds(...)) return;
        right_->nextTuple();
    }
    
    // 右表扫完了，移动左表并重新开始右表
    left_->nextTuple();
    while (!left_->is_end()) {
        right_->beginTuple();
        while (!right_->is_end()) {
            if (eval_conds(...)) return;
            right_->nextTuple();
        }
        left_->nextTuple();
    }
}

std::unique_ptr<RmRecord> Next() {
    auto left_rec = left_->Next();
    auto right_rec = right_->Next();
    auto join_rec = std::make_unique<RmRecord>(len_);
    
    // 拼接左右记录：[左记录数据][右记录数据]
    memcpy(join_rec->data, left_rec->data, left_->tupleLen());
    memcpy(join_rec->data + left_->tupleLen(), right_rec->data, right_->tupleLen());
    
    return join_rec;
}

bool eval_cond(...) {
    // 获取左部的值（可能来自左表或右表）
    auto lhs_col = get_col(rec_cols, cond.lhs_col);
    char *lhs_data;
    if (lhs_col->offset < left_->tupleLen()) {
        lhs_data = lhs_rec->data + lhs_col->offset;    // 来自左表
    } else {
        lhs_data = rhs_rec->data + (lhs_col->offset - left_->tupleLen()); // 来自右表
    }
    
    // 获取右部的值（类似处理）
    // ... 然后比较
}
```

**关键概念：**
- `left_`：外表（外层循环）
- `right_`：内表（内层循环）
- 算法：对于左表的每条记录，扫描右表的所有记录
- 时间复杂度：O(n × m)，其中 n 和 m 是左右表的记录数

**连接记录的布局：**
```
左表记录: [col1][col2][col3]  (偏移: 0 ~ left_->tupleLen()-1)
右表记录: [col4][col5]         (偏移: left_->tupleLen() ~ len_-1)
连接结果: [col1][col2][col3][col4][col5]
```

---

### 4. 修改算子 (UpdateExecutor)

```cpp
// 功能：更新指定记录的指定字段

std::unique_ptr<RmRecord> Next() {
    // 遍历所有待更新的记录
    for (auto &rid : rids_) {
        auto rec = fh_->get_record(rid, context_);     // 读取原记录
        
        // 应用所有的 SET 子句
        for (auto &set_clause : set_clauses_) {
            auto col = tab_.get_col(set_clause.lhs.col_name);
            
            // 类型检查
            if (col->type != set_clause.rhs.type) {
                throw IncompatibleTypeError(...);
            }
            
            set_clause.rhs.init_raw(col->len);        // 初始化新值
            
            // 更新记录中的字段
            memcpy(rec->data + col->offset,           // 字段位置
                   set_clause.rhs.raw->data,          // 新值
                   col->len);                         // 字段长度
        }
        
        fh_->update_record(rid, rec->data, context_); // 写回磁盘
    }
    return nullptr;
}
```

**关键概念：**
- `rids_`：要更新的记录位置列表（由 WHERE 子句确定）
- `set_clauses_`：SET 子句列表（哪些字段改成什么值）
- `tab_`：表的元数据
- 操作：读取 → 修改 → 写回

**示例：**
```sql
UPDATE students SET age = 20, name = 'Alice' WHERE id = 1;
```
- `rids_` = [rid_of_id_1]
- `set_clauses_` = [{lhs: age, rhs: 20}, {lhs: name, rhs: 'Alice'}]

---

### 5. 删除算子 (DeleteExecutor)

```cpp
// 功能：删除指定的记录

std::unique_ptr<RmRecord> Next() {
    // 遍历所有待删除的记录
    for (auto &rid : rids_) {
        fh_->delete_record(rid, context_);             // 删除记录
    }
    return nullptr;
}
```

**关键概念：**
- `rids_`：要删除的记录位置列表（由 WHERE 子句确定）
- 操作：简单地调用 delete_record

**示例：**
```sql
DELETE FROM students WHERE age < 18;
```
- 先通过顺序扫描找到所有 age < 18 的记录
- 将它们的 Rid 收集到 `rids_` 中
- 然后批量删除

---

## 数据结构速查

### Rid (Record ID)
```cpp
struct Rid {
    int page_no;   // 页号
    int slot_no;   // 槽号
};
```

### RmRecord (记录)
```cpp
struct RmRecord {
    char* data;    // 记录数据
    int size;      // 记录大小
};
```

### ColMeta (列元数据)
```cpp
struct ColMeta {
    std::string tab_name;  // 表名
    std::string name;      // 列名
    ColType type;          // 类型 (INT/FLOAT/STRING)
    int len;               // 长度
    int offset;            // 在记录中的偏移量
};
```

### Condition (条件)
```cpp
struct Condition {
    TabCol lhs_col;        // 左部列
    CompOp op;             // 运算符 (=, !=, <, >, <=, >=)
    bool is_rhs_val;       // 右部是值还是列
    TabCol rhs_col;        // 右部列
    Value rhs_val;         // 右部值
};
```

---

## 常用函数

### ix_compare - 比较两个值
```cpp
int ix_compare(const char *a, const char *b, ColType type, int col_len);
// 返回值：a < b 返回 -1，a == b 返回 0，a > b 返回 1
```

### memcpy - 复制内存
```cpp
memcpy(void *dest, const void *src, size_t n);
// 从 src 复制 n 个字节到 dest
```

### get_col - 查找列元数据
```cpp
auto col = get_col(rec_cols, target_col);
// 在列元数据列表中查找指定的列
```

---

## 火山模型执行流程

```
查询: SELECT name FROM students WHERE age > 18

执行计划树:
    Projection (name)
         ↓
    SeqScan (age > 18)
         ↓
      students

执行流程:
1. Projection.beginTuple()
   → SeqScan.beginTuple() 找到第一条 age > 18 的记录

2. Projection.Next()
   → SeqScan.Next() 获取记录
   → 提取 name 字段
   → 返回投影后的记录

3. Projection.nextTuple()
   → SeqScan.nextTuple() 找到下一条 age > 18 的记录

4. 重复步骤 2-3，直到 Projection.is_end() 返回 true
```

---

## 调试技巧

### 1. 打印调试信息
```cpp
// 在关键位置添加输出
std::cout << "Current rid: page=" << rid_.page_no 
          << ", slot=" << rid_.slot_no << std::endl;
```

### 2. 断点设置位置
- `beginTuple()` 开始处
- `nextTuple()` 开始处  
- `eval_cond()` 返回处
- `Next()` 返回前

### 3. 检查常见错误
- ✅ 指针是否为 nullptr
- ✅ 偏移量是否越界
- ✅ 类型是否匹配
- ✅ 迭代器是否已到末尾

---

## 性能优化提示

### SeqScan 优化
- 使用索引扫描代替全表扫描
- 尽早过滤不符合条件的记录

### Join 优化
- 将小表作为外表（左表）
- 考虑使用 Hash Join 或 Sort-Merge Join
- 如果有索引，使用索引嵌套循环连接

### Update/Delete 优化
- 批量操作以减少 I/O
- 维护索引时考虑批量更新

---

## 实验验证清单

- [ ] SeqScan 能正确过滤记录
- [ ] Projection 能正确选择列
- [ ] Join 能正确连接两表
- [ ] Update 能正确修改记录
- [ ] Delete 能正确删除记录
- [ ] 所有单元测试通过
- [ ] 代码有完整的中文注释
- [ ] 无内存泄漏
- [ ] 无未定义行为

---

**快速参考完毕！祝实验顺利！**
