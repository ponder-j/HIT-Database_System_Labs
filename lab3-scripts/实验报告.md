# 实验3：数据定义的实现 - 实验报告

## 一、实验概述

本实验实现了 Rucbase 数据库系统的元数据管理功能，主要完成了 `SmManager` 类中的三个关键函数：
- `open_db()` - 打开数据库
- `close_db()` - 关闭数据库
- `drop_table()` - 删除表

通过这些实现，Rucbase 能够支持 CREATE TABLE、DROP TABLE、show tables 和 desc 等命令。

## 二、实现说明

### 2.1 SmManager::open_db() 函数实现

**功能**: 打开数据库，加载元数据，打开所有表文件和索引文件

**实现思路**:
1. 检查数据库目录是否存在，如果不存在则抛出 `DatabaseNotFoundError` 异常
2. 使用 `chdir()` 进入数据库目录
3. 读取元数据文件 `db.meta`，使用重载的 `>>` 操作符将元数据反序列化到 `db_` 对象中
4. 遍历所有表的元数据：
   - 使用 `rm_manager_->open_file()` 打开表文件，并将文件句柄存储到 `fhs_` 映射中
   - 遍历每个表的所有索引，使用 `ix_manager_->open_index()` 打开索引文件，并将索引句柄存储到 `ihs_` 映射中
5. **关键点**: 保持在数据库目录中，不切换回父目录。这样后续的 `flush_meta()`、`show_tables()` 等操作才能在正确的位置进行

**核心代码位置**: `src/system/sm_manager.cpp:87-122`

**设计要点**:
- 使用 `std::ifstream` 读取元数据文件
- 使用 `emplace()` 方法将文件句柄添加到映射中，避免不必要的拷贝
- 通过 `ix_manager_->get_index_name()` 获取索引文件名，保证命名一致性

### 2.2 SmManager::close_db() 函数实现

**功能**: 关闭数据库，将所有数据刷新到磁盘

**实现思路**:
1. 调用 `flush_meta()` 将元数据写入磁盘
2. 遍历所有索引句柄 `ihs_`：
   - 调用 `ix_manager_->close_index()` 关闭每个索引文件
   - 该操作会自动将索引文件的脏页刷新到磁盘
3. 清空 `ihs_` 映射
4. 遍历所有表文件句柄 `fhs_`：
   - 调用 `rm_manager_->close_file()` 关闭每个表文件
   - 该操作会自动将表文件的脏页刷新到磁盘
5. 清空 `fhs_` 映射

**核心代码位置**: `src/system/sm_manager.cpp:135-153`

**设计要点**:
- 先刷新元数据，再关闭索引文件，最后关闭表文件，保证数据一致性
- 使用 `get()` 方法获取 `unique_ptr` 的原始指针传递给关闭函数
- 关闭操作由底层的 `IxManager` 和 `RmManager` 负责刷新缓冲区

### 2.3 SmManager::drop_table() 函数实现

**功能**: 删除指定的表，包括表文件、索引文件和元数据

**实现思路**:
1. 检查表是否存在，如果不存在则抛出 `TableNotFoundError` 异常
2. 获取表的元数据
3. 删除该表的所有索引：
   - 遍历表的所有索引元数据
   - 使用 `ix_manager_->get_index_name()` 获取索引文件名
   - 从 `ihs_` 映射中查找对应的索引句柄，如果存在则先关闭再从映射中移除
   - 使用 `ix_manager_->destroy_index()` 删除索引文件
4. 删除表文件：
   - 从 `fhs_` 映射中查找表文件句柄，如果存在则先关闭再从映射中移除
   - 使用 `rm_manager_->destroy_file()` 删除表文件
5. 从元数据对象 `db_.tabs_` 中删除该表的元数据
6. 调用 `flush_meta()` 将更新后的元数据写入磁盘

**核心代码位置**: `src/system/sm_manager.cpp:233-277`

**设计要点**:
- 先关闭文件句柄，再删除物理文件，避免访问已删除的文件
- 使用迭代器查找句柄，避免重复查找
- 删除操作的顺序：索引文件 -> 表文件 -> 元数据，保证数据一致性
- 最后调用 `flush_meta()` 持久化元数据变更

## 三、关键技术点

### 3.1 元数据管理

Rucbase 的元数据采用三层结构：
- **ColMeta**: 字段元数据，包含字段名、类型、长度、偏移量等信息
- **TabMeta**: 表元数据，包含表名、字段列表、索引列表
- **DbMeta**: 数据库元数据，包含数据库名和所有表的映射

元数据通过重载的 `<<` 和 `>>` 操作符进行序列化和反序列化，存储在 `db.meta` 文件中。

### 3.2 文件句柄管理

系统使用两个映射管理文件句柄：
- `fhs_`: `std::unordered_map<std::string, std::unique_ptr<RmFileHandle>>` - 表文件句柄
- `ihs_`: `std::unordered_map<std::string, std::unique_ptr<IxIndexHandle>>` - 索引文件句柄

使用 `unique_ptr` 管理文件句柄的生命周期，避免内存泄漏。

### 3.3 目录切换策略

数据库采用文件夹组织：
- 每个数据库对应一个同名文件夹
- 文件夹内包含 `db.meta` 元数据文件、表文件和索引文件
- `create_db()` 在创建数据库后切换回父目录
- `open_db()` 在打开数据库后保持在数据库目录中
- 这样设计使得所有数据库操作都在正确的工作目录下进行

### 3.4 缓冲区管理

文件关闭操作会自动触发缓冲区刷新：
- `ix_manager_->close_index()` 内部调用 `buffer_pool_manager_->flush_all_pages()`
- `rm_manager_->close_file()` 内部调用 `buffer_pool_manager_->flush_all_pages()`
- 保证所有脏页在文件关闭前写入磁盘

## 四、测试验证

实现完成后，使用提供的单元测试进行验证：

```bash
cd src/test/query
python query_unit_test.py basic_query_test1.sql
```

测试覆盖以下功能：
1. CREATE TABLE - 创建表并验证元数据
2. SHOW TABLES - 显示所有表
3. DROP TABLE - 删除表并验证
4. 错误处理 - 验证重复创建表、删除不存在的表等错误情况

## 五、实现亮点

1. **完整的错误处理**: 对不存在的数据库/表、重复操作等异常情况都进行了检查
2. **资源管理**: 使用 RAII 和智能指针管理资源，避免内存泄漏
3. **模块化设计**: 充分利用 `RmManager` 和 `IxManager` 的接口，保持代码简洁
4. **数据一致性**: 严格按照正确的顺序进行关闭和删除操作，保证数据一致性
5. **代码可读性**: 添加了详细的注释说明实现逻辑和关键设计决策

## 六、总结

本实验通过实现 Rucbase 的元数据管理功能，深入理解了：
1. 数据库元数据的组织和管理方式
2. 文件系统和缓冲区管理的协同工作机制
3. DDL 语句的底层实现原理
4. 资源管理和错误处理的最佳实践

实现的代码通过了所有单元测试，能够正确支持 CREATE TABLE、DROP TABLE、SHOW TABLES 和 DESC 等数据定义语句。
